{"id":472351577,"lang":"cpp","time":"2 months, 2 weeks","timestamp":1616692004,"status_display":"Accepted","runtime":"80 ms","url":"/submissions/detail/472351577/","is_pending":"Not Pending","title":"LRU Cache","memory":"42 MB","code":"class LRUCache {\npublic:\n    list<int> l;\n    unordered_map<int, pair<int, list<int>::iterator>> m;\n    int c;\n    \n    LRUCache(int capacity) {\n        c = capacity;\n    }\n    \n    void update(int key) {\n        // Erase\n        l.erase(m[key].second);\n        \n        // Insert at the head\n        l.push_front(key);\n        \n        // Update the reference in the map\n        m[key].second = l.begin();\n    }\n    \n    int get(int key) {\n        if (m.find(key) == m.end())\n            return -1;\n        \n        int res = m[key].first;\n        \n        // Update this to be the most recent\n        update(key);\n        \n        return res;\n    }\n    \n    void put(int key, int value) {\n        // Update\n        if (m.find(key) != m.end()) {\n            update(key);\n            \n            // Update the value\n            m[key].first = value;\n        }\n        else {\n            if (l.size() == c) {\n                // Cache is full\n                // Remove the LRU entry\n                int k = l.back();\n                \n                // Remove from the list\n                l.pop_back();\n                \n                // Remove from the map\n                m.erase(k);\n            }\n            // Insert now.\n            // Cache is not full\n            // Insert at the head of the list\n            l.push_front(key);\n\n            // Insert in the map\n            m[key] = make_pair(value, l.begin());\n        }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */","compare_result":"11111111111111111111","title_slug":"lru-cache"}