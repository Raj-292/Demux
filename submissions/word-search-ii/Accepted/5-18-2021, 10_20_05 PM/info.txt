{"id":494955167,"lang":"cpp","time":"3Â weeks","timestamp":1621356605,"status_display":"Accepted","runtime":"168 ms","url":"/submissions/detail/494955167/","is_pending":"Not Pending","title":"Word Search II","memory":"9.2 MB","code":"class Solution {\npublic:\n    vector<string> res;\n    int m,n;\n    \n    struct trieNode{\n        trieNode* next[26] = {NULL};\n        bool isEndHere = false;\n        // store the complete word if end there\n        string wordTillHere = \"\";\n    };\n    trieNode* root = new trieNode();\n    \n    void buildTrie(string word){\n        trieNode* temp = root;\n        for(char c:word){\n            if(temp->next[c-'a']==NULL) temp->next[c-'a']=new trieNode();\n            temp=temp->next[c-'a'];\n        }\n        temp->isEndHere = true;\n        // store the word ending here\n        temp->wordTillHere = word;\n    }\n    \n    void dfs(int i,int j,trieNode* node,vector<vector<char>>& board){\n        // cout << i << j << endl;\n        char c = board[i][j];\n        // if current character does not exists\n        if(c=='$' ||node->next[c-'a']==NULL) return;\n        // move to next node in trie\n        node = node->next[c-'a'];\n        // create logic for finding answer\n        // check if ANY WORD END HERE\n        if(node->isEndHere){\n            res.push_back(node->wordTillHere);\n            // reset the string to avoid duplicates\n            node->wordTillHere = \"\";\n            node->isEndHere = false;\n        }\n        // recursive calls if current node exists\n        board[i][j]='$';\n        if(i>0) dfs(i-1,j,node,board);\n        if(i<m-1) dfs(i+1,j,node,board);\n        if(j>0) dfs(i,j-1,node,board);\n        if(j<n-1) dfs(i,j+1,node,board);\n        board[i][j]=c;\n    }\n    \n    \n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n        // create the trie with words array\n        for(string s:words){\n            buildTrie(s);\n        }\n        m = board.size();\n        if(board.size()==0) return res;\n        n = board[0].size();\n        // traverse through each unit of metric\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                dfs(i,j,root,board);\n            }\n        }\n        return res;\n    }\n};","compare_result":"1111111111111111111111111111111111111111","title_slug":"word-search-ii"}