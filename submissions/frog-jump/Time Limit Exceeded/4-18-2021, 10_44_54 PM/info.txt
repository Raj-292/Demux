{"id":482251953,"lang":"cpp","time":"1 month, 3 weeks","timestamp":1618766094,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/482251953/","is_pending":"Not Pending","title":"Frog Jump","memory":"N/A","code":"class Solution {\npublic:\n    bool canCross(vector<int>& stones) {\n        if(stones[1] != 1)\n            return false;\n        \n        int n = stones.size(), i, j;\n        unordered_map<int, int> m;\n        vector<vector<bool>> dp(n, vector<bool>(n+1, false));\n        \n        // Populate the map and the base case\n        for(i = 0; i < n; i++){\n            m[stones[i]] = i;\n            dp[n-1][i+1] = true;\n        }\n            \n        // DP table\n        for(i = n-2; i >= 1; i--) {\n            for(j = 1; j <= n; j++) {\n                // 3 cases\n                // j-1\n                if (j > 1 && m.find(stones[i]+j-1) != m.end())\n                    dp[i][j] = dp[i][j] || dp[m[stones[i]+j-1]][j-1];\n                \n                // j\n                if(m.find(stones[i]+j) != m.end())\n                    dp[i][j] = dp[i][j] || dp[m[stones[i]+j]][j];\n                \n                // j+1\n                if (m.find(stones[i]+j+1) != m.end())\n                    dp[i][j] = dp[i][j] || dp[m[stones[i]+j+1]][j+1];\n            }\n        }\n        \n        return dp[1][1];\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111110","title_slug":"frog-jump"}