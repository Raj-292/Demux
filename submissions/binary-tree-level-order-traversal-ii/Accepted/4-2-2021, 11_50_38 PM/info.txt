{"id":475603982,"lang":"cpp","time":"2 months, 1 week","timestamp":1617387638,"status_display":"Accepted","runtime":"100 ms","url":"/submissions/detail/475603982/","is_pending":"Not Pending","title":"Binary Tree Level Order Traversal II","memory":"54.9 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrderBottomHelper(TreeNode* root, int& height) {\n        if (!root) {\n            height = 0;\n            return {};\n        }\n        \n        int hl, hr;\n        vector<vector<int>> rl, rr;\n        rl = levelOrderBottomHelper(root->left, hl);\n        rr = levelOrderBottomHelper(root->right, hr);\n        \n        int curr_ht = 1 + max(hl, hr);\n        \n        // cout << hl << \", \" << hr << endl;\n        // cout << rl.size() << \", \" << rr.size() << endl;\n\n        vector<vector<int>> r;\n        bool is_left_smaller = false;\n        \n        if (hr > hl)\n            is_left_smaller = true;\n        else\n            is_left_smaller = false;\n        \n        for (int i = 0; i < max(hl,hr)-min(hl,hr); i++) {\n            if (is_left_smaller)\n                r.push_back(rr[i]);\n            else\n                r.push_back(rl[i]);\n        }\n        \n        int start = max(hl,hr)-min(hl,hr);\n        for (int i = start; i < max(hl,hr); i++) {\n            if (is_left_smaller) {\n                r.push_back(rl[i-start]);\n                r[(int)r.size()-1].insert(r[(int)r.size()-1].end(), rr[i].begin(), rr[i].end());\n            }\n            else {\n                r.push_back(rl[i]);\n                r[(int)r.size()-1].insert(r[(int)r.size()-1].end(), rr[i-start].begin(), rr[i-start].end());\n            }\n        }\n        \n        // Push this current element\n        if ((int)r.size() < curr_ht)\n            r.push_back({});\n        \n        r[curr_ht-1].push_back(root->val);\n        \n        height = curr_ht;\n        return r;\n    }\n//     int getHeight(TreeNode* root) {\n//         if (!root)\n//             return 0;\n        \n//         return 1 + max(getHeight(root->left), getHeight(root->right));\n//     }\n    \n//     void levelOrderBottomHelper(TreeNode* root, int height, vector<vector<int>>& res) {\n//         if (!root)\n//             return;\n        \n//         res[height-1].push_back(root->val);\n        \n//         levelOrderBottomHelper(root->left, height-1, res);\n//         levelOrderBottomHelper(root->right, height-1, res);\n    // }\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\n        int ht;\n        return levelOrderBottomHelper(root, ht);\n    }\n};","compare_result":"1111111111111111111111111111111111","title_slug":"binary-tree-level-order-traversal-ii"}